int 		already_added(const int *s, int value, int size)
{
	int 	i;

	i = 0;
	while (i < size)
	{
		if (s[i] == value)
			return (1);
		i++;
	}
	return (0);
}

int 		get_neighbours(int *s, const int *mx, int i, int size)
{
	int 	j;

	j = 0;
	while (j < size)
	{
		if (mx[j] != 0 && !already_added(s, j, size))
		{
			s[i] = i;
		}
		j++;
	}
	return (1);
}

int 		find_node(int *s, int size, int value)
{
	int 	i;

	i = 0;
	while (i < size)
	{
		if (s[i] == value)
			return (i);
		i++;
	}
	return (-1);
}

t_path 		*get_shortest_path(int **mx, int size)
{
	int 	i;
	int 	j;
	int 	*queue;

	i = 0;
	queue = init_tab(size, 0);
	while (i < size)
	{
		get_neighbours(queue, mx[i], i, size);
		i++;
	}
	print_tab(queue, size);
//	return (get_reverse_path(&s, size - 1, mx));
}


	/* two paths */
//	int 	m[4][4] = {
//			/* A */	{0, 1, 1, 0},
//			/* B */	{1, 0, 1, 1},
//			/* C */	{1, 1, 0, 1},
//			/* D */	{0, 1, 1, 0},
//	};

	/* no paths */
//	int 	m[4][4] = {
//			/* A */	{0, 1, 1, 0},
//			/* B */	{1, 0, 0, 0},
//			/* C */	{1, 0, 0, 0},
//			/* D */	{0, 0, 1, 0},
//	};

	/* two paths with one common node ! ! ! */
//	int 	m[5][5] = {
//			/* A */	{0, 1, 1, 0, 0},
//			/* B */	{1, 0, 0, 1, 0},
//			/* C */	{1, 0, 0, 1, 0},
//			/* D */	{0, 1, 1, 0, 1},
//			/* E */	{0, 0, 0, 1, 0},
//	};

//	int 	m[4][4] = {
//			/* A */	{0, 1, 1, 0},
//			/* B */	{0, 0, 0, 1},
//			/* C */	{0, 0, 0, 1},
//			/* D */	{0, 0, 1, 0},
//	};